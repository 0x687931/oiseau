#!/bin/bash
# Remove merged git worktrees with progress/timeout handling

set -euo pipefail

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m'

print_info() { echo -e "${BLUE}ℹ${NC} $1"; }
print_success() { echo -e "${GREEN}✓${NC} $1"; }
print_warning() { echo -e "${YELLOW}⚠${NC} $1"; }
print_error() { echo -e "${RED}✗${NC} $1"; }
print_header() { echo -e "${BOLD}${CYAN}$1${NC}"; }

get_default_branch() {
    # Try to get from remote HEAD
    local default_branch
    default_branch=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's|^refs/remotes/origin/||')

    if [ -n "$default_branch" ]; then
        printf '%s\n' "$default_branch"
        return 0
    fi

    # Fallback: check which common default branch exists
    for branch in main master trunk; do
        if git show-ref --verify --quiet "refs/heads/$branch" 2>/dev/null; then
            printf '%s\n' "$branch"
            return 0
        fi
    done

    # Ultimate fallback
    printf '%s\n' "main"
    return 1
}

usage() {
    cat <<'EOF'
Usage: bin/worktree-prune-merged [options]

Automatically delete worktrees whose branches have already been merged.

Options:
  --base <branch>        Base branch to compare against (default: auto-detected)
  --timeout <seconds>    Max seconds to wait for git worktree remove (default: 900)
  --dry-run              Show what would be removed without deleting
  --skip-preclean        Skip deleting tmp/cache, node_modules, etc. before pruning
  --status               Show current prune status and queued worktrees
  --abort                Stop a running prune job (uses PID file)
  -h, --help             Show this help message

Examples:
  bin/worktree-prune-merged
  bin/worktree-prune-merged --base main --timeout 600
  bin/worktree-prune-merged --status
EOF
}

# Default to empty - will be auto-detected if not provided via --base flag
BASE_BRANCH=""
DEFAULT_TIMEOUT=900
DRY_RUN=false
SKIP_PRE_CLEAN=false
STATUS_ONLY=false
ABORT_ONLY=false

while [[ $# -gt 0 ]]; do
    case "$1" in
        --base)
            BASE_BRANCH="$2"
            shift 2
            ;;
        --timeout)
            DEFAULT_TIMEOUT="$2"
            shift 2
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --skip-preclean)
            SKIP_PRE_CLEAN=true
            shift
            ;;
        --status)
            STATUS_ONLY=true
            shift
            ;;
        --abort)
            ABORT_ONLY=true
            shift
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        *)
            print_error "Unknown option: $1"
            echo ""
            usage
            exit 1
            ;;
    esac
done

if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    print_error "Not inside a git repository"
    exit 1
fi

# Auto-detect base branch if not provided via --base flag
if [ -z "$BASE_BRANCH" ]; then
    BASE_BRANCH=$(get_default_branch)
fi

REPO_ROOT="$(git rev-parse --show-toplevel)"
cd "$REPO_ROOT"
PROJECT_NAME="$(basename "$REPO_ROOT")"
GIT_DIR_RAW="$(git rev-parse --git-dir)"
if [[ "$GIT_DIR_RAW" = /* ]]; then
    GIT_DIR="$GIT_DIR_RAW"
else
    GIT_DIR="$REPO_ROOT/$GIT_DIR_RAW"
fi

STATE_DIR="$GIT_DIR/tild"
PID_FILE="$STATE_DIR/worktree-prune-merged.pid"
mkdir -p "$STATE_DIR"

stat_mtime() {
    local file="$1"
    if [ ! -e "$file" ]; then
        echo 0
        return 0
    fi
    if stat -f %m "$file" >/dev/null 2>&1; then
        stat -f %m "$file"
    else
        stat -c %Y "$file"
    fi
}

seconds_to_human() {
    local total=$1
    local hours=$((total / 3600))
    local minutes=$(((total % 3600) / 60))
    local seconds=$((total % 60))
    local parts=()
    if [ "$hours" -gt 0 ]; then
        parts+=("${hours}h")
    fi
    if [ "$minutes" -gt 0 ]; then
        parts+=("${minutes}m")
    fi
    parts+=("${seconds}s")
    printf "%s" "${parts[*]}"
}

terminate_process_tree() {
    local pid="$1"
    if ! kill -0 "$pid" 2>/dev/null; then
        return 0
    fi

    local pgid
    pgid=$(ps -o pgid= "$pid" 2>/dev/null | tr -d ' ')
    if [ -n "${pgid:-}" ]; then
        kill -TERM "-$pgid" 2>/dev/null || true
    else
        kill -TERM "$pid" 2>/dev/null || true
    fi
    sleep 2
    if kill -0 "$pid" 2>/dev/null; then
        if [ -n "${pgid:-}" ]; then
            kill -KILL "-$pgid" 2>/dev/null || true
        else
            kill -KILL "$pid" 2>/dev/null || true
        fi
    fi
}

cleanup() {
    rm -f "$PID_FILE"
}

ensure_single_instance() {
    if [ -f "$PID_FILE" ]; then
        local existing_pid
        existing_pid="$(cat "$PID_FILE" 2>/dev/null || true)"
        if [ -n "$existing_pid" ] && kill -0 "$existing_pid" 2>/dev/null; then
            print_error "Another worktree prune is running (PID $existing_pid)"
            print_info "Check status with: bin/worktree-prune-merged --status"
            exit 1
        fi
        print_warning "Found stale PID file (PID $existing_pid). Removing."
        rm -f "$PID_FILE"
    fi
    echo $$ > "$PID_FILE"
    trap cleanup EXIT
    trap 'cleanup; exit 1' INT TERM
}

resolve_base_ref() {
    local candidate="$1"
    if git show-ref --verify --quiet "$candidate"; then
        echo "$candidate"
        return 0
    fi
    if git show-ref --verify --quiet "refs/heads/$candidate"; then
        echo "$candidate"
        return 0
    fi
    if git show-ref --verify --quiet "refs/remotes/$candidate"; then
        echo "$candidate"
        return 0
    fi
    if git show-ref --verify --quiet "refs/remotes/origin/$candidate"; then
        echo "origin/$candidate"
        return 0
    fi
    return 1
}

BASE_REF="$(resolve_base_ref "$BASE_BRANCH" 2>/dev/null || true)"
if [ -z "${BASE_REF:-}" ]; then
    print_error "Base branch '$BASE_BRANCH' not found locally or on origin"
    print_info "Run: git fetch origin $BASE_BRANCH"
    exit 1
fi

WORKTREE_PATHS=()
WORKTREE_BRANCHES=()
MERGED_BRANCHES=()

collect_worktrees() {
    WORKTREE_PATHS=()
    WORKTREE_BRANCHES=()
    local line=""
    local current_path=""
    local current_branch=""
    while IFS= read -r line || [ -n "$line" ]; do
        case "$line" in
            worktree\ *)
                if [ -n "$current_path" ]; then
                    add_worktree_entry "$current_path" "$current_branch"
                fi
                current_path="${line#worktree }"
                current_branch=""
                ;;
            branch\ *)
                current_branch="${line#branch }"
                current_branch="${current_branch#refs/heads/}"
                ;;
            "")
                if [ -n "$current_path" ]; then
                    add_worktree_entry "$current_path" "$current_branch"
                    current_path=""
                    current_branch=""
                fi
                ;;
        esac
    done < <(git worktree list --porcelain)

    if [ -n "$current_path" ]; then
        add_worktree_entry "$current_path" "$current_branch"
    fi
}

add_worktree_entry() {
    local path="$1"
    local branch="$2"
    if [ -z "$path" ] || [ "$path" = "$REPO_ROOT" ]; then
        return
    fi
    WORKTREE_PATHS+=("$path")
    WORKTREE_BRANCHES+=("$branch")
}

collect_merged_branches() {
    MERGED_BRANCHES=()
    while IFS= read -r merged_branch; do
        [ -z "$merged_branch" ] && continue
        MERGED_BRANCHES+=("$merged_branch")
    done < <(git branch --merged "$BASE_REF" --format '%(refname:short)')
}

branch_is_merged() {
    local target="$1"
    local merged=""
    for merged in "${MERGED_BRANCHES[@]}"; do
        if [ "$merged" = "$target" ]; then
            return 0
        fi
    done
    return 1
}

branch_has_unpushed_commits() {
    local branch="$1"
    local remote_ref="refs/remotes/origin/$branch"
    local ahead=0

    if git show-ref --verify --quiet "$remote_ref"; then
        ahead=$(git rev-list "origin/$branch..$branch" --count 2>/dev/null || echo "0")
    else
        ahead=$(git rev-list "$BASE_REF..$branch" --count 2>/dev/null || echo "0")
    fi

    if [ "$ahead" -gt 0 ]; then
        return 0
    fi
    return 1
}

preclean_worktree() {
    if $SKIP_PRE_CLEAN; then
        return 0
    fi

    local path="$1"
    local heavy_dirs=(
        "tmp/cache"
        "tmp/storage"
        "tmp/screenshots"
        "tmp/uploads"
        "tmp/pids"
        "tmp/sockets"
        "node_modules"
        "log"
        "storage"
        "public/packs"
        "public/assets"
        "public/output"
        ".bundle"
        "vendor/bundle"
        "vendor/cache"
    )

    for rel in "${heavy_dirs[@]}"; do
        local target="$path/$rel"
        if [ -d "$target" ]; then
            print_info "  Pre-clearing $rel"
            rm -rf "$target"
        fi
    done
}

run_with_timeout() {
    local timeout="$1"
    local description="$2"
    shift 2
    local log_file
    log_file="$(mktemp -t tild-prune-log.XXXXXX)"

    "$@" >"$log_file" 2>&1 &
    local cmd_pid=$!
    local start_time
    start_time=$(date +%s)
    local spinner="|/-\\"
    local spinner_index=0

    while kill -0 "$cmd_pid" 2>/dev/null; do
        local now
        now=$(date +%s)
        local elapsed=$((now - start_time))
        local spinner_char="${spinner:spinner_index:1}"
        printf "\r  %s… %s (elapsed %s)" "$description" "$spinner_char" "$(seconds_to_human "$elapsed")"
        spinner_index=$(((spinner_index + 1) % 4))

        if [ "$elapsed" -ge "$timeout" ]; then
            printf "\n"
            print_warning "Timeout reached after $(seconds_to_human "$timeout")"
            terminate_process_tree "$cmd_pid"
            wait "$cmd_pid" 2>/dev/null || true
            cat "$log_file"
            rm -f "$log_file"
            return 124
        fi
        sleep 1
    done

    wait "$cmd_pid"
    local status=$?
    printf "\r\033[K"
    if [ "$status" -ne 0 ]; then
        printf "\n"
        cat "$log_file"
    fi
    rm -f "$log_file"
    return "$status"
}

ensure_worktree_safe() {
    local path="$1"
    local branch="$2"

    if [ ! -d "$path" ]; then
        print_warning "Worktree directory missing: $path"
        return 0
    fi

    local status_output
    status_output="$(git -C "$path" status --porcelain)"
    if [ -n "$status_output" ]; then
        print_warning "Skipping $branch - worktree has uncommitted or untracked changes"
        return 1
    fi

    if branch_has_unpushed_commits "$branch"; then
        print_warning "Skipping $branch - branch has unpushed commits"
        return 1
    fi

    return 0
}

delete_local_branch() {
    local branch="$1"
    if git show-ref --verify --quiet "refs/heads/$branch"; then
        git branch -d "$branch" >/dev/null 2>&1 || git branch -D "$branch" >/dev/null 2>&1 || true
        print_info "  Deleted local branch $branch"
    fi
}

show_status() {
    collect_worktrees
    collect_merged_branches

    print_header "Worktree prune status (${PROJECT_NAME})"
    if [ -f "$PID_FILE" ]; then
        local pid
        pid="$(cat "$PID_FILE" 2>/dev/null || true)"
        if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
            print_info "Active prune job PID: $pid"
            ps -p "$pid" -o pid,pgid,etime,state,command | sed 's/^/  /'
        else
            print_warning "PID file present but process not running"
        fi
    else
        print_info "No running prune job"
    fi

    local lock_file="$GIT_DIR/index.lock"
    if [ -f "$lock_file" ]; then
        local lock_mtime
        lock_mtime=$(stat_mtime "$lock_file")
        local age=0
        if [ "$lock_mtime" -gt 0 ]; then
            age=$(( $(date +%s) - lock_mtime ))
        fi
        print_warning "Git index lock present (age $(seconds_to_human "$age"), $lock_file)"
    else
        print_success "Git index free"
    fi

    local pending=0
    for idx in "${!WORKTREE_PATHS[@]}"; do
        local branch="${WORKTREE_BRANCHES[$idx]}"
        local path="${WORKTREE_PATHS[$idx]}"
        if [ -z "$branch" ]; then
            continue
        fi
        if branch_is_merged "$branch"; then
            if [ $pending -eq 0 ]; then
                echo ""
                print_info "Merged worktrees pending removal:"
            fi
            pending=$((pending + 1))
            print_info "  $branch -> $path"
        fi
    done

    if [ "$pending" -eq 0 ]; then
        print_success "No merged worktrees pending deletion"
    fi
}

abort_running_job() {
    if [ ! -f "$PID_FILE" ]; then
        print_info "No running prune job found"
        return 0
    fi

    local pid
    pid="$(cat "$PID_FILE" 2>/dev/null || true)"
    if [ -z "$pid" ]; then
        rm -f "$PID_FILE"
        print_warning "PID file was empty"
        return 0
    fi

    if kill -0 "$pid" 2>/dev/null; then
        print_warning "Stopping prune job (PID $pid)..."
        terminate_process_tree "$pid"
        rm -f "$PID_FILE"
        print_success "Stopped worktree-prune-merged (PID $pid)"
    else
        print_warning "Process $pid not running. Removing stale PID file."
        rm -f "$PID_FILE"
    fi
}

if $STATUS_ONLY; then
    show_status
    exit 0
fi

if $ABORT_ONLY; then
    abort_running_job
    exit 0
fi

ensure_single_instance

if ! [[ "$DEFAULT_TIMEOUT" =~ ^[0-9]+$ ]]; then
    print_error "Timeout must be a positive integer"
    exit 1
fi

print_header "Pruning merged worktrees ($PROJECT_NAME)"
print_info "Base branch: $BASE_REF"
print_info "Timeout per worktree: $(seconds_to_human "$DEFAULT_TIMEOUT")"
if $DRY_RUN; then
    print_info "Dry-run mode enabled"
fi
if $SKIP_PRE_CLEAN; then
    print_warning "Skipping pre-clean of heavy directories"
fi
echo ""

collect_worktrees
collect_merged_branches

if [ "${#WORKTREE_PATHS[@]}" -eq 0 ]; then
    print_success "No secondary worktrees detected"
    exit 0
fi

if [ "${#MERGED_BRANCHES[@]}" -eq 0 ]; then
    print_info "No branches are merged into $BASE_REF yet"
    exit 0
fi

removed=0
skipped_dirty=0
timed_out=0
failed=0

for idx in "${!WORKTREE_PATHS[@]}"; do
    branch="${WORKTREE_BRANCHES[$idx]}"
    path="${WORKTREE_PATHS[$idx]}"

    if [ -z "$branch" ]; then
        continue
    fi

    if ! branch_is_merged "$branch"; then
        continue
    fi

    print_header "Removing $branch"
    print_info "Path: $path"

    if ! ensure_worktree_safe "$path" "$branch"; then
        skipped_dirty=$((skipped_dirty + 1))
        echo ""
        continue
    fi

    if $DRY_RUN; then
        print_info "[dry-run] Would remove $path"
        removed=$((removed + 1))
        echo ""
        continue
    fi

    preclean_worktree "$path"

    if run_with_timeout "$DEFAULT_TIMEOUT" "Deleting worktree" git worktree remove "$path" --force; then
        print_success "Deleted worktree for $branch"
        delete_local_branch "$branch"
        removed=$((removed + 1))
    else
        status=$?
        if [ "$status" -eq 124 ]; then
            print_error "Timed out deleting $branch"
            timed_out=$((timed_out + 1))
        else
            print_error "git worktree remove failed (exit $status)"
            failed=$((failed + 1))
        fi
    fi
    echo ""
done

cleanup

print_header "Summary"
print_info "Removed: $removed"
print_info "Skipped (safety): $skipped_dirty"
print_info "Timed out: $timed_out"
print_info "Failed: $failed"

if [ "$timed_out" -gt 0 ] || [ "$failed" -gt 0 ]; then
    print_warning "Some worktrees could not be removed automatically"
    print_info "Inspect with: bin/worktree-prune-merged --status"
    exit 1
fi

print_success "All merged worktrees have been pruned"
